# [포트폴리오] 🏆 AI 프롬프트 엔지니어링 실패 및 해결 사례 모음

이 문서는 프로젝트(WalkMate) 진행 중 발생한 **핵심 기능 구현 실패 사례 6가지**와, AI 프롬프트를 어떻게 고쳐가며 실현가능한 코드로 이끌어냈는지를 보여주는 포트폴리오용 자료입니다.

---

## 📌 Case 1: 하이브리드 앱 환경에서의 하드웨어 제어 모듈 도입 (아키텍처 불일치)

**목표:** 앱 내 실시간 객체 인식 카메라(`VisionCamera`) 컴포넌트 구현
*   **🔴 Failure 1 (단순 기능 요구):** "리액트 앱에서 카메라 켜고 사물 탐지해서 화면에 박스 쳐주는 컴포넌트 만들어줘."
    *   **결과:** AI가 모바일 전용 `react-native-vision-camera` 모듈을 제안함. 현재 프로젝트(Vite + Capacitor 기반의 하이브리드 웹)에서는 네이티브 권한 모듈이 없어 `useCameraPermission is not exported by react-native-web` 빌드 에러 발생.
    *   **원인:** AI는 "리액트 앱"이라는 키워드만 보고 'React Native' 생태계로 임의 가정함.
*   **🔴 Failure 2 (에러 로그에만 의존한 디버깅):** "위 에러 나는데 프로젝트는 Capacitor야. 어떻게 해결해?"
    *   **결과:** AI가 강제로 `react-native-web` 맵핑을 시도해 땜질 처방을 줬으나, 객체(`boxes`) 좌표를 렌더링하지 못하거나 네이티브 크래시가 연쇄 발생함.
*   **🟢 Success (환경과 제약조건 명시):** "내 프로젝트는 React Native가 아니라 **React 기반의 순수 웹 앱(Vite)이고 Capacitor로 감싼 구조**야. 따라서 네이티브 전용 모듈은 안 돼. 이 환경에서 **네이티브 의존성 없이** 웹캠 API(`react-webcam`)를 띄우고 실시간 프레임을 캡처해 WASM 모듈(`NpuTflite`)로 넘기는 코드로 다시 설계해 줘."
*   **💡 Insight (어필 포인트):** 단순히 AI가 짜준 코드를 복붙하는 것이 아니라, 내 프로젝트의 구조(React+Capacitor)를 스스로 통제하고, "설계 호환성 결함"을 파악해 라이브러리를 폐기 및 웹 표준으로 재설계하는 **결단력과 아키텍처 이해도**를 보여줍니다.

---

## 📌 Case 2: 2D 객체 인식(YOLO) 한계를 극복한 3D 거리/방향 휴리스틱 설계

**목표:** YOLO 모델이 인식한 바운딩 박스를 통해 사용자와 장애물 간의 거리 및 방향 계산
*   **🔴 Failure 1 (AI 수동성):** "사물이나 차를 인식하면 그게 얼마나 떨어져 있는지 거리를 계산해줘."
    *   **결과:** AI가 "단일 카메라 이미지로는 심도(Depth)를 알 수 없으니 LiDAR 센서가 필요하다"며 불가능하다고 답변.
*   **🔴 Failure 2 (추상적 요구):** "그냥 박스 크기로 대충 계산하는 코드 짜줘."
    *   **결과:** 픽셀 단위 크기에만 의존해 기기 해상도(화면 비율)에 따라 인식 거리가 10m도 되었다가 1m도 되는 등 들쭉날쭉함.
*   **🟢 Success (지표 제공 및 연산식 역제안):** "카메라 뷰는 640x640 캔버스로 정규화되어 있어. 이 안에서 발견된 Bounding Box의 가로/세로 중 가장 긴 비율(`Math.max(w, h)`)이 1.0(화면 꽉참)일 때 약 1m 거리로 치환하는 **가상 핀홀 역산 공식**을 적용하고, 박스 중심점의 X좌표(0~1)를 3등분하여 좌/우/정면을 판별하는 휴리스틱 로직을 설계해줘."
*   **💡 Insight (어필 포인트):** AI는 정답이 없는 도메인에서 방어적으로 나오거나 포기하는 경향이 있습니다. 물리적 한계 상황에서 개발자 본인이 유효한 '근사치 계산(Heuristic)' 방향을 프롬프트로 역제안해야 AI가 실무용 알고리즘을 짤 수 있다는 점을 어필할 수 있습니다.

---

## 📌 Case 3: 실시간 NPU 비전 카메라의 비동기 스레드 폭주 제어

**목표:** 3초 주기로 카메라 프레임을 비동기 추론(NPU)하여 모니터링하기
*   **🔴 Failure 1 (비동기 지연 미고려):** "3초마다 웹캠 화면을 캡처해서 객체 인식 추론을 돌리는 코드를 짜줘."
    *   **결과:** AI가 단순 `setInterval` 안에 `async` 추론 함수를 넣음.
*   **🔴 Failure 2 (근본 원인 오판):** "앱을 켜두면 점점 버벅이다가 메모리 부족으로 튕겨. 최적화해줘."
    *   **결과:** AI가 `useMemo`나 캔버스 재활용 등 불필요한 리렌더링 방지 팁만 제공함. 실제 원인은 이전 추론이 (성능상 3초 초과 등의 이유로) 안 끝났는데 다음 추론 틱이 발동되어 스레드가 폭주/중첩 실행되는 문제였음.
*   **🟢 Success (비동기 동시성 제어 명시):** "`setInterval` 안에서 비동기 추론(`NpuTflite.detect`)을 대기(`await`)할 때, **이전 추론 사이클이 끝나지 않았다면 새 사이클이 중첩 실행되지 않도록** `useRef`를 이용해 실행 중 플래그(Lock, `isRunningRef`)를 걸고 finally 블록에서 해제하는 로직을 포함해서 코드를 작성해."
*   **💡 Insight (어필 포인트):** AI가 작성한 비동기 코드는 '항상 0초 만에 이상적으로 즉시 응답'할 것을 가정한 교과서적 코드인 경우가 많습니다. 디바이스 리소스를 활용하는 작업에선 타이머와 비동기 동시성 제어(Concurrency Control) 메커니즘을 명시해야 안정성을 확보할 수 있음을 배웠습니다.

---

## 📌 Case 4: 음성 인식(STT/TTS) 목적지 확인 UX 상태 머신 루프 오류

**목표:** 사용자가 음성으로 목적지 확인 시 자연스러운 긍정/부정 응답 처리 루프 구현
*   **🔴 Failure 1 (단일 패턴 의존):** "사용자 음성을 STT로 받아서 '응'이면 넘어가고 아니면 다시 검색하는 컴포넌트 짜줘."
    *   **결과:** AI가 `text === '응'` 단순 조건문으로 설계하여, 사용자가 "어 맞아", "그래" 라고 대답하면 전부 부정(아니)으로 처리해버림.
*   **🔴 Failure 2 (예외 상황(Fallback) 누락):** "응, 그래, 맞아 같은 키워드 배열을 만들어서 방어해줘."
    *   **결과:** 긍정/부정은 분기되었으나, 주변 소음으로 STT 결과가 비어있거나 이상한 문장이 들어왔을 때, 다시 물어보는 `RetryScreen` 렌더링 상태로 빠져나가지 못하고 앱이 멈춤(무한 루프 혹은 데드락).
*   **🟢 Success (상태 머신 및 자연어 처리 흐름 제안):** "한국어 발화 특성을 고려하여 긍정/부정 키워드 셋을 정규식(Regex)으로 매칭해. 만약 매칭이 안 되거나(Timeout), 인식에 실패하면 단순히 에러를 던지지 말고 `RetryScreen` Fallback UI 컴포넌트를 띄운 뒤에 다시 TTS로 '{목적지}이 맞으신가요?'를 재요청하는 Flow Chart 형태의 **상태 머신(State Machine)**을 React Hook과 useEffect로 엮어줘."
*   **💡 Insight (어필 포인트):** AI에게 예외 케이스의 '목록'만 외우게 할 것이 아니라, 상태 전환의 흐름(Flow)과 Fallback UI를 통합적으로 설계해 달라고 명시해야 완결성 높은 실무적인 UX/UI 루프 구조가 나옴을 깨달았습니다.

---

## 📌 Case 5: 외부 API (지도 경로) 연동 시 데이터 인터페이스 스키마 불일치

**목표:** 자체 백엔드에서 받은 경로 데이터로 지도(`GuidingScreen`)에 내비게이션 파란색 선 그리기
*   **🔴 Failure 1 (AI의 통념적 가정):** "지도에 내비게이션 출발지부터 도착지까지 파란색 선을 그려줘."
    *   **결과:** AI가 내 프로젝트의 자체 백엔드를 무시하고 외부 구글 맵 Directions API 서비스를 통신해서 렌더링하는 코드를 무단으로 삽입해버림.
*   **🔴 Failure 2 (데이터 스키마 불명확):** "구글맵 API 쓰지 말고 자체 백엔드에서 받아온 경로 데이터로 선 그려."
    *   **결과:** 백엔드가 주는 데이터를 단순히 `[숫자, 숫자]` 튜플의 이중 배열로 마음대로 가정하여 프론트에서 타입 에러(Type Error) 폭탄이 터짐.
*   **🟢 Success (인터페이스/스키마 명세 강제):** "백엔드에서 받는 경로 데이터는 `[{latitude: number, longitude: number}]` 형태의 좌표 객체 배열 포맷이야. 이 배열을 `GuidingScreen` 컴포넌트의 Props로 바로 꽂아 넣고, 이 스키마에 맞춰 지도 위에 파란색 구글맵 `Polyline` 컴포넌트를 매핑하는 useEffect와 JSX 렌더링 코드로 수정해."
*   **💡 Insight (어필 포인트):** 프론트/백엔드 외부 연동을 짤 때는 '데이터가 들어온다'고 말만 해서는 부족하며, In/Out 데이터의 스키마 구조(Data Schema)와 TypeScript 인터페이스 구조를 대화 첫 줄에 박아둬야 불필요한 오류 리팩토링 시간을 아낄 수 있음을 배운 사례입니다.

---

## 📌 Case 6: 비어있는 데이터(Null)로 인한 백엔드 제약조건 위반 연쇄 예외

**목표:** 3초 주기로 위험 요소를 체크하고 무조건 백엔드로 로그 리포팅 전송하기
*   **🔴 Failure 1 (성공 경로 중심 설계):** "앞에 장애물이 감지되면 현재 위치랑 사진이랑 장애물 이름을 백엔드로 리포팅하는 API를 호출해줘."
    *   **결과:** 감지되었을 때만 if문을 타서, 아무것도 없는 '안전' 상태일 때는 서버에 모니터링 로그가 전혀 안 찍히는 문제가 생김.
*   **🔴 Failure 2 (초기값 부재로 인한 서버 500 에러):** "장애물이 없어도 3초마다 무조건 전송하게 해줘."
    *   **결과:** 1차원적으로 전송만 가능하게 뚫었더니, 장애물이 없을 때 `box` 변수가 `null`이라서 서버 DB의 Not Null 제약 필드(`distance`, `direction`)에 Null이 들어가 백엔드 서버(500)가 터짐.
*   **🟢 Success (Default Value 방어 로직 명시):** "3초 주기로 반드시 모니터링 API 콜을 해야 해. 단, 발견된 장애물(`primaryBox`)이 없다면 객체 에러를 피하기 위해 전송체(Payload)에 `distance: 0`, `direction: 'C'`, `risk_level: 1`, `hazard_type: '객체 없음'` 이라는 **디폴트(Default) 더미 데이터 초기화를 넣어서 백엔드 DB의 NOT NULL 제약조건을 우회**하도록 분기(`?:` 삼항연산자 등)를 태워 줘."
*   **💡 Insight (어필 포인트):** AI는 개발자가 요구한 "해피 로직(장애물이 있는 특정 상황)"의 구현에만 스코프를 좁히는 맹점이 있습니다. 시스템의 전체적인 연속성을 보장하기 위해 빈 데이터, 널 포인트 객체를 백업하는 **'초기값 방어 로직'**을 프롬프트 개발자가 주도적으로 설계해 넘기는 주니어-시니어 간의 역량 차이를 증명하는 부분입니다.

---

## 📌 Case 7: 보행자용 내비게이션(GPS+나침반) 센서 퓨전 최적화 실패 및 극복

**목표:** 시각장애인용 체스트 하네스(가슴 부착) 기반의 실시간 보행 내비게이션 좌표/방향 인식 구현
*   **🔴 Failure 1 (단일 센서 의존):** "내 폰의 현재 GPS 좌표랑 바라보는 나침반 방향을 지도에 화살표로 렌더링해줘."
    *   **결과:** AI가 `Geolocation.watchPosition`과 일반 `deviceorientation` 이벤트만 연결해줌. 사용자가 가만히 서있어도 센서 노이즈오차 때문에 GPS 좌표가 사방으로 튀고, 나침반 화살표가 360도로 팽이처럼 도는(지터링) 현상 발생. 
*   **🔴 Failure 2 (불안정한 보정 시도):** "GPS가 너무 튀고 나침반이 떨리니까 좀 부드럽게 움직이게 필터링 걸어줘."
    *   **결과:** AI가 단순히 이전에 측정한 값과 현재 값을 평균 내는 식의 단순 로직만 주었음. 이로 인해 방향 전환 시 2~3초가 딜레이되는 답답한 응답성 지연 현상이 발생.
*   **🟢 Success (이동 상태 기반의 센서 퓨전(Sensor Fusion) 명시):** "사용자가 걷고 있을 때(최근 4초 이내 1.5m 이상 GPS 이동)는 가슴에 붙인 스마트폰의 'GPS 이동 궤적'을 실제 사용자의 시선 방향으로 판단하여 나침반(Compass) 센서를 강력하게 보정해. 반면 서 있을 때는 나침반 센서에 저역 통과 필터(LPF, Alpha 0.15)를 먹여서 천천히 흔들림만 잡아줘. 이렇게 **상태(이동/정지)에 따라 동적으로 가중치를 부여하는 센서 퓨전** 코드로 다시 엮어줘."
*   **💡 Insight (어필 포인트):** 모바일 센서 데이터는 항상 노이즈가 존재한다는 "물리 엔진의 현실성"을 AI에게 직접 부여한 사례입니다. AI가 주는 순진무구한 API 호출 코드를 넘어, 이동과 정지 상태라는 **상황 컨텍스트(Context)를 프롬프트에 직접 주입하여 노이즈 필터링(LPF) 방식과 센서 가중치를 능동적으로 설계**하는 모바일 환경에 대한 높은 이해도를 증명합니다.
